# 3장. 함수 정의와 호출

## 3.1 코틀린에서의 컬렉션

- 코틀린의 컬렉션 역시 자바 컬렉션 프레임워크로 구현됨

### 읽기 전용

| 종류 | 인터페이스/타입 |
|------|----------------|
| 리스트 | `List<T>` |
| 집합   | `Set<T>` |
| 맵     | `Map<K, V>` |
| 시퀀스 | `Sequence<T>` |

### 변경 가능

| 종류 | 인터페이스/타입 |
|------|----------------|
| 리스트 | `MutableList<T>` |
| 집합   | `MutableSet<T>` |
| 맵     | `MutableMap<K, V>` |

```kotlin
val list = listOf(1, 2, 3)
val map = mapOf(1 to "one", 3 to "three", 5 to "five")
```
> 그럼 list는 val로, mutablelist는 var로만 선언해야 하는가?  
> 그게 자연스럽지만, 참조 자체를 바꿔야 한다면 var을 사용할 수도 있겠다.

## 3.2 코틀린의 편리한 함수 호출

### 3.2.1 이름 붙인 인자 (Named Variable)

- 위치 기반 인자 전달도 가능
- 이름 붙인 인자로 가독성 및 실수 개선 가능

### 3.2.2 디폴트 파라미터

- 디폴트 파라미터를 사용해 오버라이딩이 많아지는 문제를 개선
- 지정하지 않으면 디폴트가 들어감

### 3.2.3 최상위 함수와 최상위 프로퍼티

#### [최상위 함수]

- 정적인 유틸리티 클래스를 없앤다.

    - 모든 메소드가 클래스 안에서 동작해야 하는 자바, 다양한 곳에서 사용되거나 API를 크게 만들고 싶지 않은 경우에도 클래스를 만들어 사용해야 한다 → 특별한 상태나 행위 없이 정적인 메서드만 있는 클래스가 생겨남

    - 마찬가지로 해당 패키지를 임포트해야 하지만, 불필요하게 클래스로 감싸지는 게 없어짐

- 클래스가 있어야 컴파일 가능한 JVM 환경에서 실제로는 어떻게 실행되나?

    - 해당 파일명 (e.g. `join.kt` → `joinKt`) 으로 클래스를 만들어 컴파일한다. 이름을 바꾸고싶으면 `@file:JvmName` 애노테이션 쓰기

    > 자바와의 호환은 대체로 애노테이션이 처리하네

#### [최상위 프로퍼티]

- 최상위 프로퍼티로 상수를 정의할 수 있다. `const val = public static final`

    > val은 final과 같은 효과. const로 최상위 프로퍼티 쓰면 전역적으로 쓸 수 있으니 static으로 보는 듯

### 3.2.4 확장 함수와 확장 프로퍼티

- 특정 클래스 밖의 함수/프로퍼티를 특정 클래스의 인스턴스 메서드/프로퍼티로 쓸 수 있게 한다.

#### [확장 함수]

```kotlin
fun String.lastChar(): Char = this.get (this.length - 1)
```

- `수신객체.메서드명`
    - `this` 생략가능

- **확장이라는 개념은 캡슐화를 깨지 않는다**. 내부 메서드/프로퍼티 다 사용할 수 있지만 `private, protected`는 안 됨
- 수신객체 입장에서는 확장함수나 멤버 메서드나 다 똑같은 메서드이다.

- 내부적으로 정적 메서드로 구현된다. 첫 번째 인자가 수신객체.
    - 따라서 자바에서도 쉽게 호환 가능

> 하나의 파일 내에 여러 같은 이름이 있다면 임포트시 as 키워드로 이름을 바꿔 부르자. 길게 임포트 경로를 써서 구분하는 것보다는 짧게 쓰는 것이 코딩 컨벤션.

