# 4장. 클래스, 객체, 인터페이스

# 4.1 클래스, 인터페이스

## 인터페이스

```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!")
}

class Button : Clickable {
    override fun click() = println("I was clicked")
}

fun main() {
    Button.click()
}
```

- inheritance, composition 모두 클래스 이름 뒤 콜론을 붙여 사용한다.

> 인터페이스 구현은 개수 제한이 없으나 클래스 extention은 하나만 가능

- override 변경자는 필수

### 디폴트 메서드

- 메서드 본문을 구현하면 된다.
- 두 인터페이스에 동일한 이름의 디폴트 메서드가 있고 이 둘을 구현한 하나의 클래스가 있다면 둘 다 선택되는 것이 아니다(컴파일 오류). 하위 구현에서 **오버라이딩 메서드**를 직접 제공해야 한다.

> 자바 코드는 코틀린의 디폴트 구현을 사용할 수 없다. 코틀린 인터페이스를 구현하려면 모든 메서드 본문을 작성해야 한다. 코틀린은 자바 8 이전 버전과의 호환성을 위해, 인터페이스를 `추상 메서드 선언만 있는 인터페이스` + `디폴트 메서드를 정적 메서드로 구현한 코드가 있는 숨겨진 클래스`로 구현하기 때문이다. 자바는 이를 상속하면 숨겨진 클래스의 존재를 알지 못한다.

## 클래스

### open, final, abstract 변경자

#### 기본 `final`

- 코틀린에서 모든 클래스와 메서드는 기본적으로 final이다. 클래스간 상속, 하위 클래스의 오버라이딩이 불가능하다.

- 자바의 상속 시스템에서는 **기반 클래스 구현을 변경**함으로써 하위 클래스들이 잘못된 동작을 할 위험이 있기 때문이다. (취약한 기반 클래스)

> 이펙티브 자바: **상속을 위한 설계와 문서를 갖춰라. 그럴 수 없다면 상속을 금지하라.** 기반 클래스의 의도에 따라 메서드를 오버라이드 해야 하며, 오버라이드가 의도되지 않은 클래스와 메서드는 모두 final로 만들어야 한다.

#### 상속을 허용하는 `open`

예를 들어, 단순한 버튼을 제공하는 UI를 개선해 클릭 가능한 RichButton을 만든다고 할 때, 하위 클래스는 자신만의 애니메이션을 제공하되, 버튼의 기본 기능을 깰 수는 없어야 한다. 이러한 요구 사항을 다음과 같이 코드로 나타낼 수 있다.

```kotlin
open class RichButton : Clickable {
    fun disable() { /* ... */ }
    open fun animate() { /* ... */ }
    final override fun click() { /* ... */ } // 인터페이스의 멤버를 오버라이드 한 경우에는 기본적으로 open
}

class ThemedButton : RichButton() { // class 상속은 ()을 붙여야 하나요?
    override fun animate() { /* ... */ }
    override fun showOff() { /* ... */ }
}
```

- 기반 클래스나 인터페이스의 멤버를 오버라이드 한 경우에는 기본적으로 `open`이다. 금지하고 싶다면 `final`을 명시해야 한다.

> 왜 오버라이드는 기본이 open일까? 이미 오버라이드가 되었다는 사실 자체가 해당 멤버는 오버라이드가 필요하다는 반증일까?  
> 그럴 것이다. 오버라이드가 된 멤버도 기본이 final이라면 다형성의 확장성이 제한된다.

##### cf. 클래스 상속 문법

```kotlin
class ThemedButton : RichButton()
```

- 여기서 괄호가 붙는 이유: 저것 자체가 RichButton 클래스의 생성자를 호출하는 문법이다.
- 만약 생성자가 파라미터를 필요로한다면 자식 클래스는 부모 생성자에 파라미터를 전달해야 한다!

#### `abstract`

- abstract로 선언한 추상 클래스는 인스턴스화할 수 없다.
- 하위 클래스에서 **반드시 오버라이드해야만 하므로**, 항상 열려 있다. 기본이 `open`

> 마찬가지, 인터페이스의 멤버도 기본이 `open`이고, `abstract`이며  `final`로 변경할 수 없다.

## 가시성과 접근 제어자

- 기본적으로 public
- package 가시성이 없다.

> 자바의 패키지 전용 가시성은 프로젝트 외부의 코드라도 패키지가 같은 클래스를 만들기만 하면 패키지 내부 전용 선언에 접근할 수 있어, 캡슐화가 쉽게 깨질 수 있다는 단점이 있다.

| 변경자 | 클래스 멤버 | 최상위 선언 |
| :--- | :--- | :--- |
| **`public`** | 모든 곳에서 접근 가능 | 모든 곳에서 접근 가능 |
| **`internal`** | 동일한 모듈 내에서만 접근 가능 | 동일한 모듈 내에서만 접근 가능 |
| **`protected`** | 하위 클래스에서만 접근 가능 | (사용 불가) |
| **`private`** | 동일한 클래스 내에서만 접근 가능 | 동일한 파일 내에서만 접근 가능 |

> 라이브러리 개발 시 public은 외부 사용자를 위한 API에, internal은 내부 구현을 위한 코드로 사용할 수 있다. internal 코드를 변경해도 사용자 코드에 영향이 가지 않게 된다. 이 둘은 장기적인 유지보수성에 차이를 갖는 듯

- 생성자와 프로퍼티

- 데이터 클래스

- 클래스 위임

- object 키워드