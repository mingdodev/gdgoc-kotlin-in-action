# 11장. 제네릭스

제네릭은 클래스, 인터페이스, 메서드에서 사용할 데이터 타입을 구체적으로 지정하지 않고, 외부에서 지정할 수 있도록 하는 문법이다.

## 11.1 제네릭 함수와 클래스를 정의하는 방법

### 제네릭 타입 파라미터

제네릭 타입 파라미터를 받아 인스턴스를 만드는 컬렉션 중 리스트를 예시로 들어 설명한다.

```kotlin
val authors = listOf("cat", "dog", "fox")

val readers: MutableList<String> = mutableListOf()
// 또는
val readers = mutableListOf<String>()
```
- 제네릭 역시 초기화를 통해 컴파일러의 타입 추론을 이용할 수 있다.
- 빈 리스트를 만들어야 한다면 **변수** 또는 **변수를 만드는 함수**의 타입 인자를 지정한다.


### 제네릭 함수

다양한 타입의 원소를 저장하는 리스트뿐 아니라 이를 다룰 수 있는 함수도 필요하다.

```kotlin
fun <T> List<T>.slice(indices: IntRange): List<T>
```
- fun 키워드 바로 뒤에 <T>처럼 타입 파라미터를 선언한다.
- 역시 타입인자를 지정하거나 타입 추론을 사용할 수 있다.
- 확장 함수에서는 수신 객체나 파라미터 타입에 타입 파라미터를 사용할 수 있다.

> cf. 이게 확장함수인 이유는 자바 컬렉션 프레임워크 기반에다 메서드 덧붙여서 쓰려고

### 제네릭 확장 프로퍼티

```kotlin
val <T> List<T>.penultimate: T // 마지막에서 두 번째 요소
    get() = this[size - 2]
```
- 제네릭 확장 프로퍼티를 선언할 수 있다. 확장 프로퍼티는 값을 저장하지 않고 계산해서 반환하기 때문이다. [상태를 저장하지 않는다.](../03.%20함수%20정의와%20호출#확장-프로퍼티)
- 일반 프로퍼티는 타입 파라미터를 가질 수 없다. 클래스 프로퍼티에 여러 타입의 값을 저장할 수 없기 때문이다. 클래스 프로퍼티는 **값을 저장**해야 하기 때문에, 컴파일 시점에 어떤 타입일지 파악이 되어야 메모리를 확보할 수 있다.

### 제네릭 클래스 선언

```kotlin
interface List<T> {
    // 인덱스 접근에 대한 연산자 오버로딩
    operator fun get(index: Int): T 
    // ...
}
```
- 타입 파라미터를 넣은 홑화살표 구문 `<>`을 클래스나 인터페이스 이름 뒤에 붙이면 본문에서 일반적인 타입처럼 사용 가능

<br>

---

### 타입 파라미터 제약

- 제네릭 클래스나 함수는 사용할 수 있는 타입 인자를 제한할 수 있다.

```kotlin
fun <T : Number> List<T>.sum(): T
```
- 파라미터 뒤에 상계를 지정함으로써 제약을 정의할 수 있다. 타입 인자는 반드시 이 상계 타입이거나 이 상게 타입의 하위 타입이어야 한다.
- **cf.** 자바에서는 `<T extends Number> T sum(List<T> list)`처럼 extends를 쓴다.
- **e.g.** 합계는 숫자 타입에만 유효하므로 이런 경
우 타입을 제한하여 목적에 맞게 사용할 수 있다.

```kotlin
fun <T> ensureTrailingPeriod(seq: T)
    where T : CharSequence, T : Appendable {
        /*...*/
    }
```
- 여러 개의 제약을 가해야 하는 경우

#### 타입 파라미터를 널이 될 수 없는 타입으로 명시하기

479페이지

<br>

---

## 11.2 실행 시점에서 제네릭스의 동작

> 타입 소거와 실체화된 타입 파라미터

<br>

---

## 11.3 변성(Variance)

- 선언 지점과 사용 지점 변성
- 타입 별명